\documentclass{beamer}

\usetheme{Madrid}
\useoutertheme[subsection=false]{miniframes}

\definecolor{TitleColor}{HTML}{143062}
\definecolor{BodyColor}{HTML}{0d1f3f}

\setbeamercolor{frametitle}{fg=TitleColor}
\setbeamercolor{normal text}{fg=BodyColor}


\setbeamertemplate{frametitle}{
  \vspace{0.8em}
  {\usebeamerfont{frametitle}\bfseries\Large\insertframetitle}
  \par
  \vspace{0.5em}
}


\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{animate}
\usepackage{xstring} % for substring handling
\tcbuselibrary{listings,skins}

\usepackage{fontspec}

\setsansfont[
    BoldFont = Montserrat Bold,
    ItalicFont = Montserrat Italic,
    BoldItalicFont = Montserrat Bold Italic
]{Montserrat}

\renewcommand{\familydefault}{\sfdefault}

\definecolor{darkgreen}{RGB}{0,100,0} % darker than default green

\logo{\includegraphics[height=0.6cm]{Images/cloudRepublic.png}}

\lstset{
  emph={AddOpenApi,MapOpenApi,AddDocumentTransformer,AddOperationTransformer,AddSchemaTransformer},
  emphstyle=\color{blue}\bfseries,
  emph={[2]AddEndpointsApiExplorer,AddSwaggerGen,UseSwagger,UseSwaggerUI,WithOpenApi},
  emphstyle={[2]\color{darkgreen}\bfseries},
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false
}

\input{commands.tex}

\title{Farewell Swashbuckle}
\subtitle{Navigating .NET 10’s New OpenAPI Waters}
\author{Casper Dijkstra}
\date{February 27th, 2026}

\begin{document}

\titlepagecustom

\section{Setting the scene}

\begin{frame}{Swashbuckle – The Good}
Swashbuckle
\begin{itemize}
    \item Popular NuGet package for .NET
    \item \textbf{Shipped by default} in project templates before .NET 9
    \pause
    \item Two responsibilities
    \begin{itemize}
        \item \textbf{Generates OpenAPI specs} (called "Swagger" specs)
        \item Hosts the famous \textbf{Swagger UI}
    \end{itemize}
    \item Works with Minimal APIs and Controllers.
\end{itemize}
\end{frame}


\begin{frame}{Swashbuckle – The Bad}
Swashbuckle
\begin{itemize}
    \item Relies on \textbf{reflection} to inspect \textit{controllers, endpoints, models}
    \item Reads compiled assemblies at \textbf{runtime} to build the OpenAPI spec
    \item Slower startup for large projects; can miss custom attributes
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Swashbuckle – The Status}
Swashbuckle
\begin{itemize}
    \item No longer shipped by default in .NET
    \item \textit{Can} still be included in  your projects
    \pause
    \item But let's break old habits ;) 
\end{itemize}

\begin{codebox}
Farewell Swashbuckle

We're breaking up.
It's not you, it's me... 
Actually, it's .NET 10.
\end{codebox}
\end{frame}

\begin{frame}[fragile]{.NET 9 Changed the Defaults}
    \begin{itemize}
      \item \textbf{OpenAPI Docs} are now generated natively.
    
      \item NuGet
          \begin{verbatim}
              Microsoft.AspNetCore.OpenApi
          \end{verbatim}
        ships as part of the ASP.NET Core shared framework since .NET 9
    \pause
     \item \textbf{OpenAPI UI}: Microsoft intentionally stopped shipping a UI out of the box.
    \end{itemize} 
\end{frame}

\section{Document generation}
\tussenslide{OpenAPI Generation}

\begin{frame}[fragile]{Minimal OpenAPI Setup (.NET 8)}
\begin{codebox}
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.MapGet("/hello", () => "Hello world!").WithOpenApi();

app.Run();
\end{codebox}
\end{frame}

\begin{frame}[fragile]{Minimal OpenAPI Setup (.NET 10)}
\begin{codebox}
builder.Services.AddOpenApi();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    // Choice of UI
}

app.MapGet("/hello", () => "Hello world!");

app.Run();
\end{codebox}
\end{frame}

\begin{frame}{Document generation}
\begin{itemize}
    \item In .NET 8, `AddEndpointsApiExplorer()' was needed for Swashbuckle to detect minimal API endpoints. 
    \item In .NET 10, the framework automatically generates OpenAPI metadata at build-time.
    \pause
    \item This also applies to controllers!
\end{itemize}
\begin{center}
    \includegraphics[scale=0.2]{Images/carbon (5).png}
\end{center}
\end{frame}

\begin{frame}[fragile]{OpenAPI specs}
\begin{itemize}
    \item .NET 8 \begin{codebox}
        OpenApi: (...)/swagger/v1/swagger.json
        UI: (...)/swagger/index.html
    \end{codebox}
    \item .NET 10 \begin{codebox}
        OpenApi: (...)/openapi/v1.json
        UI: [404]
    \end{codebox}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{OpenAPI specs}
\begin{itemize}
    \item .NET 10 \begin{codebox}
        OpenApi: (...)/openapi/v1.json
        UI: [404]
    \end{codebox}
\end{itemize}
Or have the document created in your codebase!
\begin{center}
    \includegraphics[scale=0.2]{Images/buildGeneration.png}
\end{center}
\end{frame}

\begin{frame}{OpenAPI Changes in .NET 10}
\begin{itemize}
    \item \textbf{OpenAPI generator defaults to 3.1}
    \item Key Benefits:
        \begin{itemize}
            \item Full JSON Schema support
            \item Stronger type validation
            \item Clearer required/optional fields
        \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{OpenAPI Changes in .NET 10}
\begin{itemize}
    \item \textbf{OpenAPI generator defaults to 3.1}
    \item You however want to stick to 3.0 when working with API Management 
\end{itemize}
\begin{center}
    \includegraphics[scale=0.2]{Images/carbon.png}
\end{center}
\end{frame}


\tussenslide{Transformers}


\begin{frame}[fragile]{Transformers}
Three kinds of Transformers can be used within builder.Services.AddOpenApi

\begin{codebox}
    AddDocumentTransformer(),
    AddSchemaTransformer(),
    AddOperationTransformer()
\end{codebox}

\end{frame}

\begin{frame}[fragile]{Document Transformers}
Applies transformations globally. Set title, description, version, etc
\begin{codebox}
builder.Services.AddOpenApi("admin", options =>
{
    options.AddDocumentTransformer((document, _, _) =>
        {
            document.Info.Title = "Admin API";
            document.Info.Description = "Internal endpoints";

            return Task.CompletedTask;
        });
});
\end{codebox}

\end{frame}


\begin{frame}[fragile]{Operation Transformers}
Applies transformations per operation. Set tags, deprecations, etc

\begin{codebox}
    options.AddOperationTransformer((operation, context, _) =>
    {
        if (context.Description.RelativePath!.EndsWith("/v1"))
        {
            operation.Deprecated = true;
        }
        return Task.CompletedTask;
    });
\end{codebox}
\end{frame}


\begin{frame}[fragile]{Schema Transformers}
Applies transformations per schema. Adjust data type, apply constraints, add description

Or determine which endpoints should be included in the Openapi spec.
\end{frame}

\section{Openapi UI}
\tussenslide{OpenAPI UI}

\begin{frame}{Interacting with the APIs}
\begin{itemize}
  \item Separation of concerns:
    \begin{itemize}
      \item OpenAPI document generation
      \item UI and presentation
    \end{itemize}
  \pause
  \item Swagger UI is just one OpenAPI consumer
  \item You choose the UI that fits your team
\end{itemize}
\end{frame}

\begin{frame}{UI Options}
\begin{enumerate}
    \item \textcolor{darkgreen}{Swagger UI} (still works)
\end{enumerate}
\begin{center}
    \includegraphics[scale=0.22]{Images/swaggerUi.png}
\end{center}
Import the SwaggerUI-specific package and pass it your openapi file.
\end{frame}

\begin{frame}{UI Options}
\begin{enumerate}
    \item Swagger UI (still works)
    \item \textcolor{darkgreen}{Redoc}
\end{enumerate}
Clean and elegant \textbf{read-only} interface for API documentation
\end{frame}


\begin{frame}{UI Options}
\begin{enumerate}
    \item Swagger UI (still works)
    \item Redoc
    \item \textcolor{darkgreen}{Scalar} 
\end{enumerate}
Modern, clean \textbf{interactive UI}.
Comes with a \textbf{code snippet generator}.
\end{frame}

\begin{frame}[fragile]{Using Scalar}
\begin{codebox}
using Scalar.AspNetCore;

(...)

app.MapScalarApiReference(options =>
{
    options
        .WithTitle("My API")
        .WithTheme(ScalarTheme.Blue);
});
\end{codebox}
\end{frame}

\section{Takeaways}
\begin{frame}
    \begin{center}
        \includegraphics[scale=0.2]{Images/goodbye.png}
    \end{center}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{itemize}
  \item Native OpenAPI is lighter and more flexible
  \item Document and endpoint transformers allow us to tailor our OpenApi specs
  \begin{itemize}
      \item Only public/private APIs in document
      \item Mark API deprecated
  \end{itemize}
  \item Swagger can still be used; however, I recommend breaking up and using Scalar.
\end{itemize}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{itemize}
  \item OpenAPI generated at build-time without reflection
  \item Transformers allow you to tweak the document
  \item UI renders the experience
\end{itemize}
\end{frame}

\end{document}

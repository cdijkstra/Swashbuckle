\documentclass{beamer}

\usetheme{Madrid}
\useoutertheme[subsection=false]{miniframes}
\setbeamertemplate{footline}{}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{tcolorbox}
\tcbuselibrary{listings,skins}

\definecolor{darkgreen}{RGB}{0,100,0} % darker than default green

\logo{\includegraphics[height=0.6cm]{Images/cloudRepublic.png}}

\newtcblisting{codebox}{
  listing engine=listings,
  colback=codegray,
  colframe=black,
  listing only,
  enhanced,
  boxrule=0.5pt,
  sharp corners=northwest,
  sharp corners=southeast,
  rounded corners=southwest northeast,
  arc=10pt,
  left=4pt,
  right=4pt,
  top=4pt,
  bottom=4pt
}

\lstset{
  emph={AddOpenApi,MapOpenApi,AddDocumentTransformer,AddOperationTransformer,AddSchemaTransformer},
  emphstyle=\color{blue}\bfseries,
  emph={[2]AddEndpointsApiExplorer,AddSwaggerGen,UseSwagger,UseSwaggerUI,WithOpenApi},
  emphstyle={[2]\color{darkgreen}\bfseries},
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false
}

\input{commands.tex}

\title{Farewell Swashbuckle}
\subtitle{Navigating .NET 10â€™s New OpenAPI Waters}
\author{Casper Dijkstra}
\date{February 10th, 2026}

\begin{document}

\titlepagecustom

\section{Introduction}

\begin{frame}[fragile]
\begin{codebox}
Farewell Swashbuckle

We're breaking up.
It's not you, it's me... 
Actually, it's .NET 10.
\end{codebox}

\end{frame}

\begin{frame}{Why should we care?}
Swashbuckle
\begin{itemize}
    \item Shipped by default in earlier .NET versions
    \item Generated the OpenAPI spec and hosted the Swagger UI
    \item Third-party dependency with opinionated defaults
\end{itemize}

\pause

\begin{figure}
    \centering
    \includegraphics[scale=0.33]{Images/Conversation.png}
\end{figure}
\end{frame}

\begin{frame}[fragile]{.NET 9 Changed the Defaults}
    \begin{itemize}
      \item OpenAPI specs are now generated natively.
    
      \item NuGet
          \begin{verbatim}
              Microsoft.AspNetCore.OpenApi
          \end{verbatim}
        ships as part of the ASP.NET Core shared framework in .NET 9 and later. You typically do not need to add a package reference.
     \item Microsoft intentionally stopped shipping a UI out of the box.
    \end{itemize} 
\end{frame}

\section{Openapi generation}

\begin{frame}[fragile]{Minimal OpenAPI Setup (.NET 8)}
\begin{codebox}
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.MapGet("/hello", () => "Hello world!").WithOpenApi();

app.Run();
\end{codebox}
\end{frame}

\begin{frame}[fragile]{Minimal OpenAPI Setup (.NET 10)}
\begin{codebox}
builder.Services.AddOpenApi();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}

app.MapGet("/hello", () => "Hello world!");

app.Run();
\end{codebox}
\end{frame}

\begin{frame}[fragile]{OpenAPI specs}
\begin{itemize}
    \item In .NET 8, `AddEndpointsApiExplorer()' was needed for Swashbuckle to detect minimal API endpoints. In .NET 10, the framework    automatically generates OpenAPI metadata.
    \item .NET 8 \begin{codebox}
        OpenApi: (...)/swagger/v1/swagger.json
        UI: (...)/swagger/index.html
    \end{codebox}
    \item .NET 10 \begin{codebox}
        OpenApi: (...)/openapi/v1.json
        UI: [404]
    \end{codebox}
\end{itemize}
\end{frame}

\begin{frame}{OpenAPI Changes in .NET 10}
\begin{itemize}
    \item \textbf{OpenAPI version:} 3.0 $\to$ 3.1
    \item \textbf{Data annotations:} 
        \begin{itemize}
            \item \texttt{[Required]} fields now appear in OpenAPI as \texttt{"required": [...]} 
        \end{itemize}
    \item \textbf{Servers section:} added by default in OpenAPI 3.1
    \item \textbf{Summary:} OpenAPI 3.1 brings better JSON Schema alignment. Still some constraints from .NET attributes require transformers for full representation
    \item You can still obtain 3.0 output if you really want
\end{itemize}
\end{frame}

\section{Transformers}
\begin{frame}[fragile]{Transformers}
Three kinds of Transformers can be used within builder.Services.AddOpenApi

\begin{codebox}
    AddDocumentTransformer(),
    AddSchemaTransformer(),
    AddOperationTransformer()
\end{codebox}

\end{frame}

\begin{frame}[fragile]{Document Transformers}
Applies transformations globally. Set title, description, version, etc
\begin{codebox}
builder.Services.AddOpenApi("admin", options =>
{
    options.AddDocumentTransformer((document, _, _) =>
        {
            document.Info.Title = "Admin API";
            document.Info.Description = "Internal endpoints";

            return Task.CompletedTask;
        });
});
\end{codebox}

\end{frame}


\begin{frame}[fragile]{Operation Transformers}
Applies transformations per operation. Set tags, deprecations, etc

\begin{codebox}
    options.AddOperationTransformer((operation, context, _) =>
    {
        if (context.Description.RelativePath!.EndsWith("/v1"))
        {
            operation.Deprecated = true;
        }
        return Task.CompletedTask;
    });
\end{codebox}

\end{frame}


\begin{frame}[fragile]{Schema Transformers}
Applies transformations per schema. Adjust data type, apply constraints, add description

\begin{codebox}
foreach (var prop in context.Type.GetProperties())
{
    var maxLen = prop.GetCustomAttributes(typeof(MaxLengthAttribute), true)
         .Cast<MaxLengthAttribute>()
         .FirstOrDefault();
    if (maxLen != null && schema.Properties.ContainsKey(prop.Name))
    {
        schema.Properties[prop.Name].MaxLength = maxLen.Length;
    }
}
return Task.CompletedTask;
\end{codebox}
\end{frame}

\section{Openapi UI}
\begin{frame}{Interacting with the APIs}
\begin{itemize}
  \item Swagger UI is just one OpenAPI consumer
  \item Separation of concerns:
    \begin{itemize}
      \item OpenAPI document generation
      \item UI and presentation
    \end{itemize}
  \item You choose the UI that fits your team
\end{itemize}
\end{frame}

\begin{frame}{UI Options}
\begin{enumerate}
    \item Swagger UI (still works)
    \item Redoc
    \item \textcolor{darkgreen}{Scalar; modern, clean, developer-first $\leftarrow$ I'll show this one} 
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Using Scalar}
\begin{codebox}
using Scalar.AspNetCore;

(...)

app.MapScalarApiReference(options =>
{
    options
        .WithTitle("My API")
        .WithTheme(ScalarTheme.Blue);
});
\end{codebox}
\end{frame}

\begin{frame}{The New Mental Model}
\begin{itemize}
  \item Endpoints generate OpenAPI automatically
  \item Transformers shape the document
  \item UI renders the experience
\end{itemize}
\end{frame}

\section{Takeaways}
\begin{frame}{Key Takeaways}
\begin{itemize}
  \item Native OpenAPI is lighter and more flexible
  \item Document and endpoint transformers allow us to tailor our OpenApi specs
  \begin{itemize}
      \item Only public/private APIs in document
      \item Mark API deprecated
  \end{itemize}
  \item Swashbuckle is optional; not gone. Alternatives like scalar can also be used.
\end{itemize}
\end{frame}

\tussenslide
{
    Questions?
}
{
    Feedback?
}

\end{document}
